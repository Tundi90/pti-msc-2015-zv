<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
</head>
<body>
<h1 id="s01-6-szoftverfejlesztési-modellek">S01-6 Szoftverfejlesztési modellek</h1>
<h2 id="tartalom">Tartalom</h2>
<ol style="list-style-type: decimal">
<li><a href="#chapter01">Szoftverfejlesztési modellek (vízesés, spirális, evolúciós, RUP, XP, xUML)</a></li>
<li><a href="#chapter02">Architekturális minták és hatásuk a rendszer minőségi jellemzőire</a></li>
<li><a href="#chapter03">Tervezési minták (GoF, valamint 3 további létrehozási minta)</a></li>
<li><a href="#chapter04">Konkurens minták</a></li>
<li><a href="#chapter05">Antiminták, újratervezési minták</a></li>
</ol>
<hr />
<h2 id="szoftverfejlesztési-modellek-vízesés-spirális-evolúciós-rup-xp-xuml">1. Szoftverfejlesztési modellek (vízesés, spirális, evolúciós, RUP, XP, xUML) <a name="chapter01"></a></h2>
<p>A szoftverfejlesztés hagyományos fázisai:</p>
<ol style="list-style-type: decimal">
<li>Követelmények felmérése</li>
<li>Specifikáció</li>
<li>Vázlatos/finom tervek készítése</li>
<li>Implementáció</li>
<li>Integráció</li>
<li>Verifikáció/validáció (megfelel-e a specifikációnak/ezt kérte-e a user)</li>
<li>Rendszerkövetés/karbantartás</li>
</ol>
<p>Ezeket használják fel, vagy módosítják a következő szoftverfejlesztési modellek.</p>
<h3 id="vízesés-modell">1.1 Vízesés modell</h3>
<ul>
<li>Az egyes fázisok lineárisan követik egymást.</li>
<li>Előre megtervezi a projekt időtartamát, ráfordításait.</li>
<li>Elvárja minden fázis megfelelő dokumentálását, amely tartalmazza annak eredményeit.</li>
<li>Jól strukturált dokumentált folyamatot biztosít.</li>
<li>Nehézkes a megszervezése, tervezése és fájdalmas az új feature-ök bevezetése.</li>
<li>Nem teszi lehetővé a követelmények megváltoztatását, nem készül fel az esetleges nehézségekre.</li>
<li>Csak akkor szabad egy fázisról a következőre ugrani, ha az előző “biztosan véget ért” (reviewed &amp; verified).</li>
<li>Rövid élettartamú, előre jól specifikálható projekteknél lehet jó.</li>
</ul>
<div class="figure">
<img src="img/waterfall.png" alt="Vízesés modell" />
<p class="caption">Vízesés modell</p>
</div>
<h3 id="boehm-féle-spirális-modell">1.2 Boehm féle spirális modell</h3>
<ul>
<li>A spirál minden hurka a gyártási folyamat egy fázisát jelképezi.</li>
<li>Nincsenek fix hurkok, (pl.: specifikáció, vagy tervezés), azok az igényeknek megfelelően alakulnak ki.</li>
<li>Minden ilyen fázisnak 4 szakasza van: (az ábrán lásd bal fentről kezdve)
<ol style="list-style-type: decimal">
<li>A célok és korlátok meghatározása</li>
<li>Különböző megoldások elemzése, stratégiák kialakítása. Prototípus készítés</li>
<li>Az előző pont feladatának megoldása</li>
<li>A következő lépés megtervezése (nyilván az utolsónál ilyen nincs)</li>
</ol></li>
<li>A módszer jól dokumentálható, áttekinthető, a fázisok rugalmasak.</li>
<li>Ellenben elég drága a sok kidolgozás és próbálgatás.</li>
<li>A 3. pont kivételével nehezen párhuzamosítható.</li>
<li>a fejlesztés ciklusokban történik, amelyben az elkészített prototípusok, valamint a továbbfejlesztésével kapcsolatos kockázatok kiértékelésre kerülnek</li>
<li>előnyei:
<ul>
<li>jobban alkalmazkodik a változó követelményekhez</li>
<li>a prototípusok lehetővé teszik a nehézségek előrelátását</li>
</ul></li>
<li>hátrányai:
<ul>
<li>költségesebb a prototípus elkészítése és a kockázatkiértékelés végett</li>
<li>továbbá a prototípusok megzavarhatják a felhasználót</li>
</ul></li>
</ul>
<div class="figure">
<img src="img/boehm.png" alt="Spirális modell" />
<p class="caption">Spirális modell</p>
</div>
<h3 id="evolúciós-modell">1.3 Evolúciós modell</h3>
<ul>
<li>Akkor jó, ha nincs pontos specifikáció</li>
<li>Először a prototípust készítjük el, majd a megrendelővel folyamatosan egyeztetve jutunk el a végleges megoldásig</li>
<li>Hátránya, hogy gyenge a dokumentáció, áttekinthetetlen egy idő után és nehezen módosítható.</li>
</ul>
<h3 id="rup-rational-unified-process">1.4 RUP (Rational Unified Process)</h3>
<ul>
<li>Az UML alkotóitól egy iteratív, inkrementális módszer.</li>
<li>4 fázisa van, mindegyik állhat több iterációból, ezeken belül munkafolyamatokból: modellezés, követelményelemzés, tervezés, implementáció, tesztelés, telepítés, konfigurálás, változáskezelés, projektvezetés, stb</li>
<li>Fázisai:
<ol style="list-style-type: decimal">
<li>Előkészítés: Architektúra, költségbecslés. (Use case és activity diagramokkal)</li>
<li>Kidolgozás: Minimális kódolással az 1.) véglegesítése, innen már csak építeni kell.</li>
<li>Megvalósítás: Ez a fejlesztési fázis, egészen a tesztelésig</li>
<li>Átadás: Kb készen van, még tesztelendő, újrakiadható állapot javításokkal</li>
</ol></li>
</ul>
<div class="figure">
<img src="img/rup.png" alt="RUP" />
<p class="caption">RUP</p>
</div>
<h3 id="extreme-programming-xp">1.5 Extreme Programming (XP)</h3>
<ul>
<li>Lightweight fejlesztés, kis csapatokkal, határozatlan, változékony körülményekre.</li>
<li>Alapelvei, hogy mindig a legegyszerűbb megoldást válasszuk, azokat csináljuk meg először, van idő próbálkozni. Ha egy megoldás rossz, el kell dobni!</li>
<li>Kis csapatokban, folyamatosan tanulva, pair-programming alkalmazásával a lehető legmagasabb minőséget biztosítva kell dolgozni</li>
<li>Fázisai:
<ol style="list-style-type: decimal">
<li>Feltárás: Az architektúra kitalálása (pár hét)</li>
<li>Tervezés: Az első kiadás határidejének megállapítása (pár nap)</li>
<li>Iterációk: 1-4 hetes, 2-6 hónapos kiadások, itt történik a fejlesztés nagy része.</li>
<li>Fejlesztés, karbantartás, befejezés: Konfiguráció, bővítés, módosítás és átadás</li>
</ol></li>
</ul>
<div class="figure">
<img src="img/xp_loop.png" alt="XP" />
<p class="caption">XP</p>
</div>
<div class="figure">
<img src="img/xp_phases.png" alt="XP" />
<p class="caption">XP</p>
</div>
<h3 id="végrehajtható-uml-xuml">1.6 Végrehajtható UML (xUML)</h3>
<ul>
<li>Ebben az esetben csak egy platformfüggetlen modell van, csak a feladatra koncentrálunk.</li>
<li>Ebből pedig kódgenerálással előáll a platformfüggő termék.</li>
<li>Ezt az UML megszorításával (és kiterjesztésével) valamint az Action Specification Language-dzsel érjük el.<br />
</li>
<li>Menete:
<ul>
<li>Meghatározzuk a alrendszereket (use case és szekvencia diagramokkal)</li>
<li>Létrehozzuk a modellt (osztálydiagramok és állapotdiagramok)</li>
<li>Ellenőrizzük őket</li>
<li>Modellfordítást végzünk (kódgenerálás)</li>
<li>A komponensekből összeállítjuk a terméket</li>
</ul></li>
</ul>
<h2 id="architekturális-minták-és-hatásuk-a-rendszer-minőségi-jellemzőire">2. Architekturális minták és hatásuk a rendszer minőségi jellemzőire <a name="chapter02"></a></h2>
<ul>
<li>A rendszer kívülről látható részeit mutatja meg, a belső implementációt NEM.</li>
<li>Az elemek által nyújtott szolgáltatások, kommunikáció, hibakezelés, erőforrás használat tartozik ide.</li>
<li>A kezdeti döntések kihatnak a következő tulajdonságokra:
<ul>
<li>Rendelkezésre állás</li>
<li>Megbízhatóság</li>
<li>Teljesítmény</li>
<li>Biztonság</li>
<li>Tesztelhetőség</li>
<li>Használhatóság</li>
</ul></li>
</ul>
<p><strong>Csövek és szűrők:</strong> Adatfolyam feldolgozása a komponensek (szűrők) között. A komponensek bemenettel és kimenettel rendelkeznek és valamilyen transzformációt hajtanak végre az adatokon. Az adatokat pedig a csövek szállítják. Van passzív és aktív szűrő. Az aktív szűrő tud igényelni és küldeni is. Két aktív szűrő között a kommunikációt az egyik szűrő vagy a cső szinkronizálja. Ha a szűrők lineárisak, akkor csővezetékről beszélünk.</p>
<p><strong>Objektumelvű rendszer:</strong> A komponensek objektumok, közöttük eljáráshívással történik a kommunikáció. A belső reprezentációjuk rejtett. A kommunikációhoz kapcsolat kell, és ha az egyik publikus része változik, akkor valószínűleg a használóját is módosítani kell.</p>
<p><strong>Eseményalapú rendszer:</strong> A komponensek nem tudják, hogy más milyen eseményeket bocsát ki, mire iratkozik fel és milyen sorrendben szolgálódik ki. Sőt, nem tudni, hogy ki-mit csinál és meddig.</p>
<p><strong>Réteg szerkezetű rendszer:</strong> Minden réteg az alatta lévő szolgáltatásait használja, vele kommunikál. A módosítások max 1-2 réteget érintenek, tesztelés esetén lehet szimulálni a rétegeket.</p>
<p><strong>Gyűjtemény:</strong> Komponens adattár, komponensek veszik körbe és tárolja őket. Ha végre is hajt műveleteket, akkor táblának, ha nem, akkor adatbázisnak nevezzük. Így a komponensek függetlenek is lehetnek egymástól, jól módosítható.</p>
<p><strong>Virtuális gép, értelmező:</strong> A bemenő adatokat értelmezi, feldolgozza, majd a feldolgozó interfészen ki is adja az eredményt.</p>
<p><strong>Modell-Nézet-Vezérlő:</strong> A rétegek elkülönülnek. A modell az adatokért és a rajtuk végzett műveletekért felel. A nézet a megjelenítésért, míg a vezérlő a felhasználói utasítások kezeléséért felel. A rendszer sajnos könnyen bonyolulttá válhat.</p>
<p><strong>Továbbiak:</strong> szerver-kliens, modell-nézet, gyakran használt “módszerek”: állapotgép-rendszer, felügyelő (supervisor), monád (“számítás-építő”)</p>
<h2 id="tervezési-minták-gof-valamint-3-további-létrehozási-minta">3. Tervezési minták (GoF, valamint 3 további létrehozási minta) <a name="chapter03"></a></h2>
<ul>
<li>A Gang of Four (GoF) a &quot;Design Patterns: Elements of Reusable Object-Oriented Software” könyv négy szerzője</li>
<li>Az objektumelvű rendszer tervezésekor építünk ezekre az újrafelhasználható stratégiákra.</li>
<li><p>23 tervezési mintát írtak le amelyek 3 osztályba sorolhatóak: létrehozási, szerkezeti és viselkedési</p></li>
<li><strong>Létrehozási</strong>
<ul>
<li><strong>Egyke (Singleton):</strong> Az osztályból csak 1 példány létezhet globálisan. A változóban tárolás nem jó ötlet. Helyette tegyük a konstruktort protecteddé és egy publikus metóduson keresztül lehessen ezt meghívni, ahol a konstruálás biztonságos. Ha nem létezik még az objektum, akkor hozza létre, ha létezik, akkor azt adja vissza.</li>
<li><strong>Építő (Builder):</strong> Összetett objektumok konstruálásának szétválasztása. A konstrukciós folyamat eltérő reprezentációt hozhat létre. (konstrukció leválasztása a repr.-ről)</li>
<li><strong>Gyártó művelet (Factory Method):</strong> Az objektum létrehozási felületét úgy határozzuk meg, hogy alosztályok döntsék el, mely osztályba tartozzon az objektum.</li>
<li><strong>Absztrakt gyártó (Abstract Factory):</strong> Felület összetartozó objektumok családjának létrehozására (az interfész adja a család jelleget, mert egymás mellé kerülnek a létrehozóműveletek, a konkrét esetben pedig alákerül az implementáció). Gyártóműveletek gyártójaként is felfogható.</li>
<li><strong>Prototípus (Prototype):</strong> Új objektum létrehozása egy ilyen prototípus másolásával (clone metódus hívása). Cachelésre használható például.</li>
</ul></li>
<li><strong>Szerkezeti</strong>
<ul>
<li><strong>Összetétel (Compositer):</strong> Fa struktúra, egyedileg és egészben is kezelhetőek a résztvevő elemek, mind ugyanazzal a felülettel rendelkezik.</li>
<li><strong>Híd (Bridge):</strong> Szétválasztja az absztrakciót az implementációtól, így azok egymástól függetlenül fejleszthetőek. Futási időben lesz összekötve az absztrakt az implementációval.</li>
<li><strong>Díszítő (Wrapper):</strong> Származtatás nélkül egészíti ki az objektum műveleteit. Ehhez az objektumot be kell ágyazni egy másikba.</li>
<li><strong>Arculat (Facade):</strong> Bonyolult alrendszerek közös felülete.</li>
<li><strong>Könnyűsúlyú (Flyweight):</strong> Megosztás nagy számú objektum között, mert a sok objektum sok memóriát foglalhat. Ilyenkor érdemes a közös részeket egy másik osztályba kiszervezni.</li>
<li><strong>Helyettes (Proxy):</strong> Hozzáférhetőség szabályozása. Amíg nem akarjuk használni az objektumot, addig ne inicializálódjon.</li>
</ul></li>
<li><strong>Viselkedési</strong>
<ul>
<li><strong>Figyelő (Observer):</strong> Ha egy objektum állapotot vált, akkor a rá feliratkozottakat értesíti. A “tárgy” ismeri a “figyelőket”, fel/le tudnak iratkozni, a figyelő pedig le tudja kérdezni a figyelt tárgy állapotát.</li>
<li><strong>Iterátor (Cursor):</strong> Egy aggregátum végigjárása a szerkezet ismerete nélkül. Ezen kívül a “listát” akár több módon (visszafelé, kettőt lépve, párhuzamosan) is be lehet járni.</li>
<li><strong>Állapot (State):</strong> Állapottól függően más viselkedés (kicsit mintha osztályt váltana futás közben). Van egy context ami tartalmazza a state-et. A state egy State interfészt megvalósító osztály egy példánya. A context-ből hívhatjuk a state valamely metódusát aminek paramétere a context maga, ami pedig beállíthat a context-nek egy új állapotot (state új implementációját). Ha változott a state, akkor legközelebb már State interfész egy másik implementációja fog lefutni.</li>
<li><strong>Közvetítő (Mediator):</strong> Olyan objektum megadása, ami megmondja más objektumok, hogy működnek együtt. Nem szerencsés ha mindenki ismer mindenkit, vagy hosszú az öröklődési lánc. (az obj-ok csak a mediátort ismerik, egymást nem)</li>
<li><strong>Feljegyzés (Memento):</strong> Feljegyezzük egy objektum állapotát, hogy később visszanézhessük (pl UNDO művelethez). Csak az objektum láthatja.</li>
<li><strong>Kezelési lánc (Chain of responsibility):</strong> A kezelőket láncba fűzzük, majd valaki lekezeli az igényt. A default kezelő kerül a lánc legelejére.</li>
<li><strong>Stratégia (Strategy):</strong> Algoritmusok halmazának létrehozása, beágyazása, cserélhetősége. Van egy közös felületük, az ősosztály.</li>
<li><strong>Látogató (Visitor):</strong> Egy szerkezeten végigjárunk és végrehajtunk egy műveletet. A műveletet a szerkezet különböző pontjain máshogy kell használni. Akkor jó, ha sok különböző új művelet van, de az osztályszerkezet stabil.</li>
<li><strong>Értelmező (Interpreter):</strong> Ha egy probléma sokszor fordul elő, érdemes egy “nyelv” mondataként leírni és egy értelmezőt írni hozzá.</li>
</ul></li>
<li><strong>3 További minta-</strong>
<ul>
<li><strong>Lusta példányosítás:</strong> Olyan, mint a proxy, csak itt addig nem hozhatja létre az új objektumot, amíg nem kap rá engedélyt.</li>
<li><strong>Lusta gyártó:</strong> Gyártó művelet + lusta példányosítás.</li>
<li><strong>Objektumkészlet:</strong> Ha valakiből sok kell, akkor nem érdemes folyton létrehozni, hanem néhány darabot tárolunk és azokat adogatjuk.</li>
</ul></li>
</ul>
<h2 id="konkurens-minták">4. Konkurens minták <a name="chapter04"></a></h2>
<ul>
<li><strong>Eseményalapú aszinkron hívás:</strong> Ha egy esemény sokáig tart, egy új szálban indítjuk el</li>
<li><strong>Ütemező:</strong> szálak sorbaállítása (pl szekvenciális kód kell egy adott helyen, nem futhatnak akárhogy a szálak)</li>
<li><strong>Aktív objektum:</strong> Minden művelet futtatás külön objektum. Párhuzamosítható, szinkronizálható.</li>
<li><strong>Blokkolás:</strong> Csak akkor engedünk egy szálnak végrehajtani egy műveletet, ha az objektum egy bizonyos állapotban van. (más esetben szimplán “eldobjuk” a műveletet)</li>
<li><strong>Író-olvasó zárás:</strong> Több olvasó lehet, de egyszerre csak egy író. (írás közben nincs más I/O!)</li>
<li><strong>Threadpool:</strong> Olyan, mint az objektumkészlet.</li>
<li><strong>Termelő-fogyasztó:</strong> Aszinkron, párhuzamos folyamatok. Feladatok generálása/végrehajtása. A termelő egy közbeiktatott raktárba helyezi az objektumokat, ahonnan a fogyasztó kiveheti.</li>
</ul>
<h2 id="antiminták-újratervezési-minták">5. Antiminták, újratervezési minták <a name="chapter05"></a></h2>
<ul>
<li><strong>Antiminták</strong>
<ul>
<li><strong>Mindenható objektum:</strong> Túl sokat tud, egy idő után borzasztóan nehéz lesz a módosítás.</li>
<li><strong>Kör-ellipszis probléma:</strong> Mi az általánosabb? Mindig attól függ, milyen műveletek vannak.</li>
<li><strong>Felesleges rétegződés:</strong> Ha túl sok réteg van a rendszerben, érdemes összevonni néhányat.</li>
<li><strong>Jojó probléma:</strong> Túl hosszú az öröklődési lánc.</li>
<li><strong>Poltergeist objektum:</strong> Az osztály összes objektumának élete túl rövid (pl: paraméter átadás, üzenetküldés, stb)</li>
</ul></li>
<li><strong>Újratervezési minták</strong>
<ul>
<li><strong>Létrehozó metódus:</strong> Olyan, mint a singletonnál. Inkább legyenek olyan műveltek, amik visszaadnak egy objektumot.</li>
<li><strong>Műveletek kihelyezése:</strong> Egy bonyolult művelet egy részét kihelyezzük, ezzel több kisebb műveletre bontva, amelyek egyenként már könnyebben értelmezhetőek.</li>
<li><strong>NullObject:</strong> A nullreferencia sokszor gondot okozhat. Ilyenkor érdemes egy NullObject típust bevezetni.</li>
</ul></li>
</ul>
<h2 id="további-források">További források</h2>
<ul>
<li>Előző éves kidolgozás</li>
</ul>
</body>
</html>
