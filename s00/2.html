<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_CHTML-full" type="text/javascript"></script>
</head>
<body>
<h1 id="s0-02-típusmodellek-programozás-elmélet">S0-02 Típusmodellek (Programozás elmélet)</h1>
<h2 id="tartalom">Tartalom</h2>
<ol style="list-style-type: decimal">
<li><a href="#chapter01">Absztrakt adattípus</a></li>
<li><a href="#chapter02">Adattípus specifikációja</a></li>
<li><a href="#chapter03">Adattípus osztály</a></li>
<li><a href="#chapter04">Paraméterátadás</a></li>
<li><a href="#chapter05">Reprezentációs függvény</a></li>
<li><a href="#chapter06">Öröklődés és polimorfizmus</a></li>
<li><a href="#chapter07">Liskov féle szubsztitúciós elv</a></li>
<li><a href="#references">További források</a></li>
</ol>
<h2 id="absztrakt-adattípus">1. Absztrakt adattípus <a name="chapter01"></a></h2>
<h3 id="típus-fogalma-általában">Típus fogalma általában</h3>
<p>Mi a típus? Biteken tárolt információk jelentése, illetve hogy hogyan kell értelmezni és módosítani őket</p>
<h3 id="típus-fogalma-formálisan">Típus fogalma formálisan</h3>
<p>Egy</p>
<p><span class="math display">\[(A, F)\]</span></p>
<p>páros, ahol</p>
<ul>
<li><em>A</em>: adattípust felépítő objektumok halmaza</li>
<li><em>F</em>: objektumokon értelmezett műveletek halmaza</li>
</ul>
<h3 id="absztrakt-adattípus-adt">Absztrakt adattípus (ADT)</h3>
<ul>
<li>Szolgáltatásoknak egy halmaza, ahol a szolgáltatásokat egy megvalósító adattípus nyújtja</li>
</ul>
<p>ADT specifikációja</p>
<ul>
<li>Szolgáltatások leírása, a specifikáció nem írja elő a megvalósítás módját</li>
</ul>
<p>ADT megvalósítása</p>
<ul>
<li>ilyen szolgáltatásokat nyújtó adattípus</li>
</ul>
<p>ADT korai és modernebb megközelítése</p>
<ul>
<li>Korai megközelítésben: azonos <strong>STRUKTÚRÁJÚ</strong> adatok (C struct-ok)</li>
<li>Modern megközelítésben: azonos <strong>SZOLGÁLTATÁST</strong> nyújtó adatok (C++/Java/C# osztályok)</li>
</ul>
<h3 id="szignatúra">Szignatúra</h3>
<ul>
<li>Programozási nyelvekben ez a deklarációnak felel meg
<ul>
<li>(<em>Gondolj a függvény típusszignatúrájára Haskell-ben</em>)</li>
</ul></li>
<li><span class="math inline">\(\sum\)</span> szignatúra egy <span class="math inline">\(\sum = (S, OP)\)</span>
<ul>
<li><span class="math inline">\(S = \{ S_0, S_1, ... , S_n \}\)</span>: szortok neveinek halmaza (fajták, alaptípusok)</li>
<li><span class="math inline">\(OP = \{ f_0, f_1, ... , f_m \}\)</span>: művelet neveinek halmaza</li>
</ul></li>
<li>Az <span class="math inline">\(f_i\)</span> művelet: egy <span class="math inline">\(f_i: s_{i_1} \times s_{i_2} \times \cdots s_{i_k} \rightarrow s_{i_0}\)</span> parciális leképezés
<ul>
<li>(<span class="math inline">\(művelet: argumentum\ szortok \rightarrow target\ szortok\)</span>)</li>
</ul></li>
<li>Argumentum szortok (miből): <span class="math inline">\(s_{i_1} \times s_{i_2} \times \cdots s_{i_k}, \qquad k \geq 0\)</span></li>
<li>Target szort (mibe): <span class="math inline">\(s_{i_0}\)</span></li>
</ul>
<p>Lényeg: a műveletek szortokból szortokba képeznek le</p>
<h3 id="szignatúra-algebra">Szignatúra algebra</h3>
<ul>
<li>Ez az ami jelentést rendel a szignatúrához</li>
<li>Programozási nyelvekben ez a definíciónak (implementációnak) felelne meg</li>
<li>Az ADT lehetséges implementációját modellezi le</li>
<li><span class="math inline">\(\sum = (S, OP)\)</span> szignatúrához tartozó algebra: <span class="math inline">\(\sum_A = (S_A, OP_A)\)</span>
<ul>
<li><span class="math inline">\(S_A = \{ A_{s_0}, A_{s_1}, \cdots A_{s_n} \}\)</span>: szortok, amikhez jelentések is tartoznak (<em>hordozó halmaz</em>)</li>
<li><span class="math inline">\(OP_A = \{ f_0, f_1, ... , f_m \}\)</span>: műveletek, amikhez jelentések is tartoznak (<em>függvények</em>)</li>
<li>A <span class="math inline">\(f_i\)</span> művelet: egy <span class="math inline">\(f_i: A_{s_{i_1}} \times A_{s_{i_2}} \times  \cdots A_{s_{i_k}} \rightarrow A_{s_{i_0}}\)</span> parciális leképezés</li>
<li><span class="math inline">\(k = 0\)</span> esetén <span class="math inline">\(f_i\)</span> az <span class="math inline">\(A_{s_{i_0}}\)</span> szort konstansa</li>
</ul></li>
<li>Szortok neveihez <span class="math inline">\(\leftarrow\)</span> hordozó halmazt rendel</li>
<li>Műveletek neveihez <span class="math inline">\(\leftarrow\)</span> függvényeket rendel</li>
</ul>
<h2 id="adattípus-specifikácija">2. Adattípus specifikácija <a name="chapter02"></a></h2>
<ul>
<li>Szignatúra és szignatúra algebra: lehet, hogy van két különböző módon viselkedő szignatúra algebra!</li>
<li>Hogyan adjunk szemantikát ezekhez? Specifikációval.</li>
<li>Specifikáció: szerződés a felhasználó és a megvalósító között
<ul>
<li>Legyen a lehető legáltalánosabb, hogy ne korlátozza a megvalósítást!</li>
</ul></li>
</ul>
<h3 id="absztrakt-adattípus-specifikációja">Absztrakt adattípus specifikációja</h3>
<p>Specifikáció: <span class="math inline">\(SPEC = (\sum, E)\)</span> (alternatív jelölés: <span class="math inline">\(SPEC = (S, OP, E)\)</span>)</p>
<ul>
<li><span class="math inline">\(\sum\)</span>: szignatúra</li>
<li><em>E</em>: műveletek szemantikáját meghatározó specifikáció</li>
</ul>
<h3 id="absztrakt-adattípus-specifikációk-fajtái">Absztrakt adattípus specifikációk fajtái</h3>
<p><strong>1. Állapot elvű specifikáció (Hoare-féle módszer)</strong></p>
<ul>
<li>Műveletek elő- és utófeltételeinek halmaza</li>
<li><span class="math inline">\(\{\varphi\} P \{\psi\}\)</span>
<ul>
<li><span class="math inline">\(\varphi\)</span>: előfeltétel</li>
<li><em>P</em>: program</li>
<li><span class="math inline">\(\psi\)</span>: utófeltétel</li>
</ul></li>
</ul>
<p><strong>2. Procedurális specifikáció</strong></p>
<ul>
<li>Műveletek kiszámítási szabályainak halmaza</li>
<li>Függvény jelentésének, kiszámítási szabályának pszeudokód-szerű definiálása</li>
</ul>
<p><strong>3. Axiomatikus specifikáció (algebrai specifikáció)</strong></p>
<ul>
<li>Eljárás jelentését meghatározó logikai állítások</li>
<li>Függvények jelentését axiómákban írjuk le</li>
<li>Axiomákat rendszerint predikátumokkal adjuk meg</li>
</ul>
<h3 id="szignatúra-algebrák-közötti-homomorfizmus">Szignatúra algebrák közötti homomorfizmus</h3>
<p>(<em>morfizmus: leképezés</em>)</p>
<ul>
<li>Alaphalmazok (<em>S</em>) és műveletek (<em>OP</em>)</li>
<li>Legyen két szignatúra algebra:
<ul>
<li><span class="math inline">\(\sum_A = (S_A, OP_A)\)</span> és <span class="math inline">\(\sum_B = (S_B, OP_B)\)</span></li>
</ul></li>
</ul>
<p><span class="math inline">\(h: A \rightarrow B\)</span> egy függvénycsalád</p>
<ol style="list-style-type: decimal">
<li>Minden <em>S</em>-beli <em>s</em> szortra <span class="math inline">\(h_s: A_s \rightarrow B_s\)</span>
<ul>
<li>azaz <em>A</em> szortját <span class="math inline">\(\rightarrow\)</span> <em>B</em> megfelelő szortjára képezi le</li>
</ul></li>
<li><span class="math inline">\(\forall f_{A_i}\)</span> és <span class="math inline">\(\forall (A_{s_{i_1}}, A_{s_{i_2}}, ..., A_{s_{i_k}})\)</span> esetén: <span class="math inline">\(f_{B_i} megfelel f_{A_i}\)</span>-nek
<ul>
<li>úgy, hogy <span class="math inline">\(h_{s_{i_0}}(f_{A_i}(A_{s_{i_1}}, A_{s_{i_2}}, ..., A_{s_{i_k}}))  = f_{B_i}(h_{s_{i_1}}(A_{s_{i_1}}), ..., (h_{s_{i_k}}(A_{s_{i_k}}))\)</span></li>
<li>előző laikusan: <em>A</em>-n való homomorfizmus végrehajtása (formula bal oldala) után <em>B</em> az <em>A</em> leképezéseit fogja tartalmazni (formula jobb oldala)</li>
</ul></li>
</ol>
<h3 id="szignatúra-algebra-homomorfizmusok-speciális-esetei">Szignatúra algebra homomorfizmusok speciális esetei</h3>
<ol style="list-style-type: decimal">
<li>Átnevezés
<ul>
<li>szignatúra szortjainak és műveleteinek átnevezése</li>
</ul></li>
<li>Bővítés
<ul>
<li>szignatúra bővítése új szortokkal és műveletekkel</li>
<li>új szignatúra definíció a korábbi átvételével</li>
</ul></li>
<li>Új ábrázolás
<ul>
<li>szignatúra átvétele, meglévő szortok helyére más szortokból képzett ábrázolások</li>
</ul></li>
</ol>
<h3 id="szignatúra-algebra-izomorfizmus">Szignatúra algebra izomorfizmus</h3>
<ul>
<li>1-1 leképezés <em>A</em> és <em>B</em> között</li>
<li>Jelölés: <span class="math inline">\(A \simeq B\)</span> (<em>A</em> izomorf <em>B</em>-vel)
<ul>
<li>(<em>szürjektív: minden B-beli elemhez kapcsolódik valaki</em>)</li>
<li>(<em>injektív: minden A-beli elem különböző B-beli elemhez kapcsolódik</em>)</li>
<li>(<em>bijektív: egyszerre szürjektív és injektív</em>)</li>
</ul></li>
<li>Ha egy homomorfizmus bijektív <span class="math inline">\(\Longrightarrow\)</span> akkor <strong>izomorfizmusról</strong> beszélünk</li>
<li>Az izomorf algebrák azonosak egymással (átnevezést leszámítva)</li>
</ul>
<h3 id="adattípus-szignatúra-algebrai-megközelítésben">Adattípus szignatúra algebrai megközelítésben</h3>
<ul>
<li>Izomorfikus <span class="math inline">\(\sum\)</span> szignatúra algebrák ekvivalencia osztálya:</li>
</ul>
<p><span class="math display">\[osztály[A] = \{B \in Alg(\sum): B \simeq A\}\]</span></p>
<p>ahol</p>
<ul>
<li><em>[A]</em>: ekvivalencia osztály</li>
<li><span class="math inline">\(B \in Alg(\sum)\)</span>: <em>B</em> az <span class="math inline">\(Alg(\sum)\)</span> szignatúra algebra része</li>
<li><span class="math inline">\(B \simeq A\)</span>: <em>B</em> izomorf <em>A</em>-val</li>
</ul>
<h3 id="monomorfikus-és-polimorfikus-absztrakt-típus">Monomorfikus és polimorfikus absztrakt típus</h3>
<ul>
<li><strong>Monomorfikus</strong>
<ul>
<li>Egyetlen adattípus tudja megvalósítani</li>
<li>Minden eleme izomorf</li>
<li><strong>Csak egy ekvivalencia osztály</strong> van benne</li>
</ul></li>
<li><strong>Polimorfikus</strong>
<ul>
<li>Több adattípus tudja megvalósítani</li>
<li>Absztrakt adattípus nem monomorfikus</li>
<li><strong>Több ekvivalencia osztály</strong> is van benne</li>
</ul></li>
</ul>
<h3 id="specifikáció-homomorfizmus">Specifikáció homomorfizmus</h3>
<p>Szignatúra algebra homomorfizmus kiterjesztése a <span class="math inline">\(SPEC = (\sum, E)\)</span> specifikációban lévő műveleti szemantikát leíró <span class="math inline">\(E\)</span> specifikációban lévő</p>
<ul>
<li>változókra</li>
<li>és kifejezésekre</li>
</ul>
<p>Specifikáció változói és kifejezései leképezhetők <span class="math inline">\(\rightarrow\)</span> másik specifikáció változóira és kifejezéseire</p>
<h2 id="adattípus-osztály-specifikációja">3. Adattípus osztály specifikációja <a name="chapter03"></a></h2>
<div class="figure">
<img src="img/adattipus_osztaly_specifikacioja.png" alt="Adattípus osztály morfizmus diagramja" />
<p class="caption">Adattípus osztály morfizmus diagramja</p>
</div>
<p><strong>Specifikációk</strong></p>
<ul>
<li><em>PAR</em>: formális paraméterek tulajdonságainak specifikációja
<ul>
<li>paraméteres specifikáció esetén a specifikáció részei csak akkor lesznek meghatározva <span class="math inline">\(\Longrightarrow\)</span> amikor formális paraméterekkel példányosítjuk a specifikációt (<em>gondolj konstruktorra</em>)</li>
</ul></li>
<li><em>EXP</em>: export felület specifikációja
<ul>
<li><span class="math inline">\(EXP = PAR + (S_1, OP_1, E_1)\)</span></li>
<li>rajta értelmezett műveletek szintaxisának és szemantikájának definíciója</li>
<li>kitüntetett szortú specifikáció (<em>kitüntetett szort: szort ami az adattípus elemeit azonosítja</em>): <span class="math inline">\(EXP = (S_{EXP}, OP_{EXP}, E_{EXP})\)</span></li>
</ul></li>
<li><em>IMP</em>: import felület specifikációja
<ul>
<li><span class="math inline">\(IMP = PAR&#39; + (S_2, OP_2, E_2)\)</span></li>
<li>más osztályból átvett szolgáltatások tulajdonságainak leírása</li>
</ul></li>
<li><em>BOD</em>: törzsrész specifikációja
<ul>
<li><span class="math inline">\(BOD = IMP + eb(EXP)\)</span></li>
<li>típusosztály megvalósitása, adatok reprezentálásának definíciója</li>
<li>modul rejtett része, szortok, műveletek axiómái</li>
<li>kitüntetett szortú specifikáció: <span class="math inline">\(BOD = (S_{BOD}, OP_{BOD}, E_{BOD})\)</span></li>
</ul></li>
</ul>
<p><strong>Morfizmusok</strong></p>
<ul>
<li><em>e</em>: specifikációmorfizmus <em>PAR</em>-ből <em>EXP</em>-re
<ul>
<li>tartalmazást jelent</li>
</ul></li>
<li><em>i</em>: specifikációmorfizmus <em>PAR</em>-ból <em>IMP</em>-re
<ul>
<li>tartalmazást és átnevezést jelent</li>
</ul></li>
<li><em>ib</em>: specifikációmorfizmus <em>IMP</em>-ből <em>BOD</em>-ra
<ul>
<li>tartalmazást jelent</li>
</ul></li>
<li><em>eb</em>: kitüntetett szortú specifikációmorfizmus <em>EXP</em>-ből <em>BOD</em>-ra
<ul>
<li>reprezentációt, objektumok ábrázolásával együtt megvalósuló tartalmazást jelent</li>
</ul></li>
</ul>
<h3 id="az-adattípus-osztályspecifikációjának-részei-és-szabályai-adattípus-osztály-interfésze-konstrukciós-része-megnyílvánulási-aspektus-része-megvalósítás-része">Az adattípus osztályspecifikációjának részei és “szabályai”: adattípus osztály interfésze, konstrukciós része, megnyílvánulási aspektus része, megvalósítás része</h3>
<p><strong>1. Interfész</strong></p>
<ul>
<li>osztálynév (<em>name</em>)</li>
<li>paraméter felület (<em>PAR</em>)</li>
<li>export felület (<em>EXP</em>)</li>
<li>import felület (<em>IMP</em>)</li>
</ul>
<p><strong>2. Konstrukciós rész</strong></p>
<ul>
<li>import felület (<em>IMP</em>)</li>
<li>törzsrész (<em>BOD</em>)</li>
</ul>
<p><strong>3. Megnyilvánulási aspektus rész</strong></p>
<ul>
<li>export felület (<em>EXP</em>)</li>
<li>import felület (<em>IMP</em>)</li>
</ul>
<p><strong>4. Megvalósítás</strong></p>
<ul>
<li>törzsrész (<em>BOD</em>)</li>
</ul>

<h2 id="paraméterátadás-annak-jelentése-és-morfizmus-diagramja">4. Paraméterátadás, annak jelentése és morfizmus diagramja <a name="chapter04"></a></h2>
<p>Paraméteres specifikáció</p>
<ul>
<li>Specifikáció egyes részei akkor lesznek meghatározva <span class="math inline">\(\Longrightarrow\)</span> ha formális paraméterekkel példányosítjuk a specifikációt</li>
</ul>
<div class="figure">
<img src="img/parameter.png" alt="Paraméterátadás morfizmus diagramja" />
<p class="caption">Paraméterátadás morfizmus diagramja</p>
</div>
<ul>
<li><em>PAR</em>: paraméter specifikáció, paraméterek tulajdonságai</li>
<li><em>e</em>: specifikáció morfizmus
<ul>
<li>paraméterek specifikációjából <span class="math inline">\(\rightarrow\)</span> export specifikációba</li>
</ul></li>
<li><em>EXP</em>: export specifikáció
<ul>
<li>kitüntetett szortú specifikáció</li>
</ul></li>
</ul>
<p>Programozási nyelvekben: template-ek (C++) és generikus típusok (Java, C#)</p>
<h2 id="reprezentációs-függvény">5. Reprezentációs függvény <a name="chapter05"></a></h2>
<p>Adva egy adattípus absztrakt és konkrét specifikációja:</p>
<p><span class="math display">\[d_a = (A, F, E_a); \qquad d_c = (C, G, E_c);\]</span> <span class="math display">\[A = \{A_0, ..., A_n\}; \qquad C = \{C_0, ..., C_m\};\]</span> <span class="math display">\[F = \{f_0 \rightarrow A_0, ..., f_i: A_j ... A_k \rightarrow A_l, ...\}; \qquad
G = \{g_0: \rightarrow C_0, ..., g_i: C_j ... C_k \rightarrow C_l, ...\};\]</span></p>
<p>ahol</p>
<ul>
<li><span class="math inline">\(d_a\)</span>: adattípus absztrakt specifikációja</li>
<li><span class="math inline">\(d_c\)</span>: adattípus konkrét specifikációja</li>
<li><em>A</em>: absztrakt szortnevek</li>
<li><em>C</em>: konkrét szortnevek</li>
<li><em>F</em>: absztrakt műveletek</li>
<li><em>G</em>: konkrét műveletek</li>
</ul>
<p>Absztrakt és konkrét objektumok egymáshoz való viszonya:</p>
<p><span class="math display">\[\varphi: C \rightarrow A\]</span> <span class="math display">\[\varphi = (\varphi_0, ..., \varphi_n)\]</span> ahol <span class="math display">\[\varphi_0: C_0 \rightarrow A_0; \varphi_1: C_1 \rightarrow A_1; ...; \varphi_n: C_n \rightarrow A_n;\]</span></p>
<p>A <em>C</em> objektumhalmazt az <em>A</em> objektumhalmaz egy reprezentánsának nevezzük az adott <span class="math inline">\(\varphi\)</span> mellett</p>
<ul>
<li>ha minden <span class="math inline">\(a \in A\)</span> objektumnak létezik legalább egy <span class="math inline">\(c \in C\)</span> reprezentánsa</li>
<li>azaz <span class="math inline">\(a = \varphi(c)\)</span>.</li>
</ul>
<p>Ennek jelentősége kettős specifikációnál: <em>eb</em> megmondja hogyan reprezentáljuk <em>IMP</em>-el <span class="math inline">\(PAR + EXP\)</span>-et</p>
<h2 id="típusöröklés">6. Típusöröklés <a name="chapter06"></a></h2>
<ul>
<li>Az öröklődéssel létrehozott osztály objektuma</li>
<li>Helyettesítheti az eredeti osztály, a szuperosztály (superclass) megfelelő objektumát</li>
<li>Öröklődés során azonban a szuperosztály leképezései (publikus metódusai) újradefiniálhatók
<ul>
<li>de csak úgy, hogy azok szintaktikai formája ne változzon meg.</li>
</ul></li>
</ul>
<p>Típusöröklődés definíciója:</p>
<ul>
<li>Adva <span class="math inline">\(C = (PAR, EXP, IMP, BOD, e, i, eb, ib)\)</span> osztályspecifikáció</li>
<li>Adva <span class="math inline">\(C&#39; = (PAR&#39;, EXP&#39;, IMP&#39;, BOD&#39;, e&#39;, i&#39;, eb&#39;, ib&#39;)\)</span> osztályspecifikáció</li>
</ul>

<p>Adva <span class="math inline">\(f_s = (f_{S_P}, f_{S_E})\)</span> morfizmus:</p>
<div class="figure">
<img src="img/oroklodes.png" alt="Öröklődés morfizmus diagramja" />
<p class="caption">Öröklődés morfizmus diagramja</p>
</div>
<p>úgy, hogy</p>
<ul>
<li><span class="math inline">\(e&#39; \circ f_{S_P} = f_{S_E} \circ e\)</span></li>
<li><span class="math inline">\(pt(EXP&#39;) = f_{S_E}(pt(EXP))\)</span></li>
</ul>
<p>Morfizmus során az operációk szintaktikai formája megőrződik</p>

<h2 id="liskov-féle-szubsztitúciós-elv">7. Liskov féle szubsztitúciós elv <a name="chapter07"></a></h2>
<p>Más néven: szemantikai öröklődési követelmény</p>
<div class="figure">
<img src="img/liskov.png" alt="Szemantikai örkölődés T_1-ből T_2-be" />
<p class="caption">Szemantikai örkölődés <span class="math inline">\(T_1\)</span>-ből <span class="math inline">\(T_2\)</span>-be</p>
</div>
<p>Ha a <span class="math inline">\(T_1\)</span> típusnak minden <span class="math inline">\(o_1\)</span> objektumához létezik a <span class="math inline">\(T_2\)</span> típusnak egy olyan <span class="math inline">\(o_2\)</span> objektuma, amelyre igaz a következő:</p>
<ul>
<li>minden olyan <em>P</em> programban amely <span class="math inline">\(T_1\)</span> típusú termként van definiálva,</li>
<li>a <em>P</em> program viselkedése nem változik meg, valahányszor az <span class="math inline">\(o_1\)</span> objektumot <span class="math inline">\(o_2\)</span> objektumra cseréljük ki,</li>
</ul>
<p><span class="math inline">\(\Longrightarrow\)</span> akkor a <span class="math inline">\(T_2\)</span> a <span class="math inline">\(T_1\)</span> típus altípusa!</p>
<h2 id="további-források">8. További források <a name="references"></a></h2>
<ul>
<li>Előadás diasor</li>
</ul>
</body>
</html>
