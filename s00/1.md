S0-01 Szintézis és verifikáció (Programozás elmélet)
=======================================
Tartalom
---------------------------------------

1. [Programozási alapfogalmak](#chapter01)
2. [Elemi programok és program konstrukciók definíciói](#chapter02)
3. [Nem-determinisztikus strukturált programok formális verifikációja](#chapter03)
4. [Párhozamos programok formális verifikációja](#chapter04)
5. [Az interferencia-mentesség és a holtpont-mentesség vizsgálata](#chapter05)
6. [A kölcsönös kizárás és megvalósítása](#chapter06)
7. [További források](#references)

1.Programozási alapfogalmak <a name="chapter01"></a>
---------------------------------------
A Programozás elméletben adatközpontú megközelítést alkalmazunk. Ezzel a megközelítéssel mind a feladat, mind a
program, stb. definícióját adatok halmazán, állapottér meghatározásával írjuk le.

### Állapottér

Egy adat **típus-értékhalmaza** az adat lehetséges értékeiből áll. **Állapotnak** hívjuk azt az érték-együttest,
amikor egy feladat vagy egy program _minden_ adata felvesz a saját típus-értékhalmazából egy-egy értéket.

Formálisan:

Legyenek $A_1, ... , A_n (n\in\mathbb{N}^+)$ típusérték-halmazok, és a halmazokat
azonosító (egyedi, páronként különböző) $v_1, ... , v_n$ címkék (változók)

Minden cimke egy adatot (változó) jelöl. Egy állapot $\{v_1:a_1, ... , v_n:a_n\}$ (cimkézett értékek halmaza),
ahol minden változó felvesz egy értéket a hozzátartozó típus-értékhalmazból. ($a_i\in A_i$)

Az összes így képzett állapot halmazát **állapottérnek** nevezzük:

$$A := \{ \ \{v_1:a_1, ... ,v_n:a_n\} \ | \ a_i\in A_i \ (i=1,...,n) \ \}$$


### Feladat

A feladat egy kapcsolat (leképezés) a bemenet és az eredmény között: $F \subseteq A \times A$

Figyeljük meg, hogy az $F$ reláció csak része az $A\times A$ descartes-szorzatnak. Mivel azonban a kiinduló
állapotok csak az állapottér egy részhalmazát képzik, illetve az ezekhez rendelt állapotok ugyancsak az állapottérnek
egy részhalmazát képzik, így érthető, hogy a feladat nem feltétlenül érvényes a teljes állapottéren.

Példa:

Osztója reláció

Kérdés: $n$ osztója-e $d$-nek, melyet az $l$ logikai változó jelöl.

\begin{align*}
    A & = ( n:\mathbb{Z}, d:\mathbb{Z}, l:\mathbb{L} ) \\
    F & \subseteq A \times A \\
    & \text{ahol} \\
    D_f & = \{\{n,d,l\} \in A \ | \ d \neq 0 \} \\ 
    \forall a & \in D_F : F(a) = \{ \{n, d, l\} \in A \ | \ l = d|n \}
\end{align*}

Tehát láthatjuk, hogy az $F$ értelmezési tartományába csak azok az állapotok tartoznak bele, ahol az osztó nemnulla.
Az $l$ változó értéke $F(a)$-ban pedig aszerint alakul, hogy az $n$ osztja-e $d$-t.

#### Előfeltétel és  utófeltétel
Válasszunk egy $P$ paraméterhalmazt, mellyel az $F$ feladat felbontható két reláció kompozíciójára:
$$F = F_1 \circ F_2$$
ahol $F_1 \subseteq A \times P$ és $F_2 \subseteq P \times A$, úgy hogy: $\forall a \in D_F: F(a) = F_2(F_1(a))$

Ekkor definiálni tudjuk a feladat elő- és utófeltételét:

$\forall p \in P:$

* $Ef_P : A \rightarrow \mathbb{L}$    melyre   $[Ef_P] = F_1^{(-1)}(p)$
* $Uf_P : A \rightarrow \mathbb{L}$    melyre   $[Uf_P] = F_2(p)$

Itt a $Q : A \rightarrow \mathbb{L}$ egy állítás, aminek az igazsághalmaza: $[Q] := \{q \in Q \ | \ Q(a) \ igaz \}$. Tehát
$Ef$ olyan állítás, mely a feladat minden kezdőállapotára igazat ad, illetve az $Uf$ olyan állítás, mely az $F(a)$
állaptokra ad igaz értéket.

### Program

Egy programot sokféleképpen lehet megadni. (program-gráf, strukogram, automaták, utasítások, pszeudo- vagy programnyelv).

A program alaptermészete az, hogy különböző végrehajtásokat okoz. Tehát egy program a lehetséges
végrehajtásainak összessége. Egy ilyen végrehajtás sorozatos állapot-változásokat idéz elő, ennél fogva leírható egy
állapotsorozattal.

Példa:

$A = (n : [-5, ..., \infty ) )$

```Python
    while n != 10:
        n = n + sgn(n)
```
Ennek a lehetséges végrehajtásai a következők: 
```
     0: <0,0,0,0,0, ... >               nem terminál
     4: <4,5,6,7,8,9,10>                terminál
    10: <10>                            terminál
    13: <13,14,15,16, ... >             nem terminál
    -2: <-2,-3,-4,-5, fail >            abortál
```

A program lehet **nem-determinisztikus** (nem mindig ugyanazt az állaposorozatot adja a kezdőállapból indítva), lehetnek 
**segédváltozói**, lehet **véges** vagy **végtelen hosszú**, illetve leállhat **hibás** állapotban
vagy speciálisan **holtpontban**.

#### Alap-állapottér

A program alap-állapottere az **program interfésze**, mellyel a program a környezetével kommunikál (kezdőállapotát
a környezet adja, végállapotát a környezet kapja). Illetve ez írja le a program **alap-változóit**, melyek a program
működése során végig léteznek.

#### Fromális specifikáció

* Legyen $A$ az **alap-állapottér** ( $\text{fail} \notin A$ )
* Legyen $\overline{A}$ azon (véges komponensű) állapotterek úniója, melyeknek $A$ altere:

$$ \overline{A} := \bigcup_{A \leq B} B $$

* Jelöljük $H^{**}$-gal a $H$ elemeiből képzett összes sorozatot (lehet végtelen is).
* Jelöljük $H^{*}$-gal a $H$ elemeiből képzett összes véges sorozatot.

Ezek alapján a $A$ feletti programnak hívjuk azt az
$$ S\subseteq A \times (\overline{A} \cup \text{fail} )^{**} $$ 

relációt, melyre fennállnak a következők:

1. $D_S = A$

    a program értelmezési tartománya az alap-állapottér.
2. $\forall a \in A : \forall \alpha \in S(a): \ |a| \geq 1 \land a_1 = a$

    az állapotsorozat legalább egy hosszú és a első állapota mindig az alap-állapottérből való.
3. $\forall \alpha \in R_S : \forall i \ (1 \leq i < |\alpha| ) : \alpha_i \neq \text{fail}$

    csak az utolsó elem lehet `fail` a végrehajtási állapotsorozatban
4. $\forall \alpha \in R_S : |\alpha| < \infty \longrightarrow \alpha_{|\alpha|} \in A \cup \{\text{fail} \}$

    a véges végrehajtások utolsó állapota vagy a `fail` vagy alap-állapottérbeli állapot.

### Megoldás

Egy program akkor old meg egy feladatot (a program helyes a feladat szempontjából),
ha végrehajtásai a feladat kezdőállapotaiból indulva a feladat megfelelő célállapotaiban állnak meg. Ekkor a feladat
állapottere és a program alap-állapottere azonos kell legyen.
Ilyenkor a program végrehajtásai között találjuk a feladat kezdőállapotából induló végrehajtásokat,
amelyekről azt kell eldönteni, hogy terminálnak-e (hibátlan véges hosszú) és végállapotuk a feladat által megkívánt
valamelyik célállapot lesz-e.

#### Megoldás minősített esetei

* **Parciális helyesség**: Ha a program a feladat kezdőállapotaiból indulva leáll, akkor ezt a feladatnak
    megfelelő célállapotban teszi. (A leállást nem követeljük meg.)
* **Leállás**: A feladat kezdőállapotából indulva leáll a program. (Hány vagy legfeljebb hány lépés múlva
    következik ez be? Kizárható-e a végtelen vagy a hibás működés, ez utóbbiba beleértve a holtpont helyzet
    kialakulását is.)
* **Teljes helyesség**:
    A program a feladat kezdőállapotaiból indulva a feladatnak megfelelő célállapotban (hibátlanul) áll le.
* **Gyengén teljes helyesség**: Ilyenkor a helyesség-vizsgálat során figyelmen kívül hagyjuk a holtpont kialakulását.

2.Elemi programok és program konstrukciók definíciói <a name="chapter02"></a>
---------------------------------------

### Elemi programok

#### Üres program

Az üres program gyakorlatilag az identitásfüggvény. ( $S := skip$ )
$$skip(\sigma) = <\sigma>$$
(Azaz az üres program egyetlen állapota a kezdőállapot.)

#### Értékadás

Az értékadás megváltoztatja egy változó értékét, így új állapotot idéz elő. ($S := v:=f(v)$)
\begin{align*}
    (v:=f(v))(\sigma) & = <\sigma, \sigma'> \\
                        &\text{ahol} \quad \sigma' \in f(\sigma) \quad \text{ha } \sigma \in D_f \\
                        &\text{és} \quad \sigma' \in \text{fail} \quad \text{ha } \sigma \notin D_f
\end{align*}

### Program konstrukciók

#### Szekvencia

A szekvenciával két program összefűzését érhetjük el.

Legyen $S_1$ és $S_2$ közös állapotterű ($A$) programok.

\begin{align*}
(S_1;S_2)(\sigma) & = \{ \alpha \ | \ \alpha \in S_1(\sigma)\cap \overline{A}^{\infty} \} \\
                    & \cup \{ \alpha \ | \ \alpha \in S_1(\sigma) \text{ és } |\alpha| < \infty \text{ és } \alpha_{|\alpha|} = \text{fail} \} \\
                    & \cup \{ \alpha \otimes \beta \ | \ \alpha \in S_1(\sigma) \cap \overline{A}^{*} \text{ és } \beta \in S_2(\alpha_{|\alpha|}) \} \\
\end{align*}

Tehát:

1. Ha az $S_1$ nem terminál, akkor a szekvencia is csak a végtelen hosszú $S_1$ végrehatás lesz.
2. Ha az $S_1$ abortál, akkor a szekvencia is csak az abortált $S_1$ végrehajtás lesz.
3. Ha az $S_1$ hiba nélkül áll le, akkor ahhoz az állapotsorozathoz fűzzük hozzá az $S_2$ végrehajtását az $S_1$
    utolsó állapotából. (a csatlakozásnál a duplikátumokat redukáljuk)

#### Elágazás

Az elágazással feltételek alapján változtathatjuk a sorozatot.

Legyenek $S_1 , ... , S_n$ programok és $\pi_1 , ... , \pi_n$ feltételek, amelyeknek közös alap-állapottere az $A$.

\begin{align*}
\text{if } \pi_1 \rightarrow S_1 , ... , \pi_n \rightarrow S_n \text{ fi} & = \\
\bigcup_{\substack{i=1 \\ \sigma \in D_{\pi_i} \land \pi_i(\sigma)}}^n S_i(\sigma) \ & \cup \ \begin{cases} <\sigma, \text{fail}> \quad \text{ha } & \exists i \in [1..n]: \sigma \notin D_{\pi_i} \ \lor\\
                                                                                                                                                   & \lor \ \forall i \in [1..n] : \sigma \in D_{\pi_i} \land \lnot\pi_i(\sigma) 
                                                                                                                                                   \\ 
                                                                                                                                                   \emptyset \text{ különben}\end{cases}
\end{align*}

Tehát:

1. Minden olyan $S_i$ végrehajtás úniója ahol $\sigma$ megfelel a $\pi_i$ feltételnek
2. Ha van egy olyan feltétel, ahol a $\sigma$ nincs benne a feltétel értelmezési tartományában, vagy a $\sigma$ egyik
    feltételnek sem tesz eleget, akkor a végrehajtás abortál.

#### Ciklus

A ciklussal ismétlődő sorozatokat állíthatunk elő.

Legyen $S_0$ program és $\pi$ feltétel, amelyeknek közös alap-állapottere az $A$.

\begin{align*}
(\text{while } \pi \text{ do } S_0 \text{ od})(\sigma) = 
\begin{cases}
    (S_0 ; \text{while } \pi \text{ do } S_0 \text{ od}) \quad & \text{ha } \sigma \in D_\pi \land \pi(\sigma) \\
    <\sigma> \quad & \text{ha } \sigma \in D_\pi \land \lnot\pi(\sigma) \\
    <\sigma, \text{fail}> \quad & \text{ha } \sigma \notin D_\pi
\end{cases}
\end{align*}

Tehát:

1. Amíg $\pi$ teljesül, addig szekvenciálisan összefűzzük az $S_0$-t a "rekurzívan" hívott ciklussal újra
2. Ha nem teljesül a feltétel, akkor gyakorlatilag egy `skip`-et hajtunk végre
3. Ha a $\sigma$ nincs benne a $\pi$ értelmezési tartományában, akkor a program abortál

#### Atomi utasítás

Atomi utasításnak párhuzamos/konkurens programok esetén tulajdonítunk fontos szerepet. Az atomi utasítás nem
tartalmazhat sem ciklust, sem várakozó utasítást. Ekkor az utasítást egyszerre, megszakítás nélkül kell végrehajtani.

$$ [S](\sigma) = S(\sigma)$$

Elsőre furának tűnhet, de szemantikai értelemben valóban nincs különbség.

#### Várakozó utasítás

A várakozó utasítás párhuzamos/konkurens programok esetén szinkronizációra használható.

$$(\text{await }\beta\text{ then } S \text{ta})(\sigma) = 
\begin{cases} 
<\sigma, \text{fail}> \quad & ha \sigma \notin D_\beta \\
S(\sigma) \quad & ha \sigma \in D_\beta \land \beta(\sigma)\\
(\text{await }\beta\text{ then } S \text{ta})(\sigma) \quad & ha \sigma \in D_\beta \land \lnot\beta(\sigma)
\end{cases}$$

A haramdik esetben nem párhuzamos program esetén nincs, ami megváltoztassa a $\sigma$ értékét, így ez holtpontot okozhat.
A várakozó utasítás esetén a $\beta$ kiétékelése és az $S$ program atomi műveletként hajtódik végre. Az $S$ nem tartalmaz
sem ciklust, sem várakozó utasítást.

#### Párhuzamos blokk

A párhuzamos blokkokkal leírhatjuk, hogy melyik programrészek futhatnak párhuzamosan.

Legyen $S_1, ... , S_n$ a párhuzamosan végrehajtott program ún. programágai. Az ütemező ezek közül választhat egyet
végrehajtásra. 

Amennyiben az ütemező az $i$-edig ágnak adja a vezérlést:

\begin{align*}
(\text{parbegin } & S_1 \lVert ... \lVert S_i \lVert ... \lVert S_n \text{ parend})(\sigma) = \\
& \begin{cases}
    (\text{parbegin } S_1 \lVert ... \lVert S_{i-1} \lVert S_{i+1} \lVert ... \lVert S_n \text{ parend})(\sigma) & \quad \text{ha } S_i = \text{skip}\\
    (u;\text{parbegin } S_1 \lVert ... \lVert S_{i-1} \lVert T_{i} \lVert S_{i+1} \lVert ... \lVert S_n \text{ parend})(\sigma) & \quad \text{ha } \text{skip} \neq S_i = u;S_i \\
\end{cases}
\end{align*}

3.Nem-determinisztikus strukturált programok formális verifikációja <a name="chapter03"></a>
---------------------------------------

//TODO: A helyesség-vizsgálati módszerek menete, a nevezetes programszerkezetek helyességének szabályai

4.Párhozamos programok formális verifikációja <a name="chapter04"></a>
---------------------------------------

//TODO: A helyesség-vizsgálati módszerek menete, a nevezetes programszerkezetek helyességének szabályai

5.Az interferencia-mentesség és a holtpont-mentesség vizsgálata <a name="chapter05"></a>
---------------------------------------

(Owicki-Gries) 

6.A kölcsönös kizárás és megvalósítása <a name="chapter06"></a>
---------------------------------------
7.További források <a name="references"></a>
---------------------------------------
* Előadás diasor