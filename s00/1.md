S0-01 Szintézis és verifikáció (Programozás elmélet)
=======================================
Tartalom
---------------------------------------

1. [Programozási alapfogalmak](#chapter01)
2. [Elemi programok és program konstrukciók definíciói](#chapter02)
3. [Nem-determinisztikus strukturált programok formális verifikációja](#chapter03)
4. [Párhozamos programok formális verifikációja](#chapter04)
5. [Az interferencia-mentesség és a holtpont-mentesség vizsgálata](#chapter05)
6. [A kölcsönös kizárás és megvalósítása](#chapter06)
7. [További források](#references)

1.Programozási alapfogalmak <a name="chapter01"></a>
---------------------------------------
A Programozás elméletben adatközpontú megközelítést alkalmazunk. Ezzel a megközelítéssel mind a feladat, mind a
program, stb. definícióját adatok halmazán, állapottér meghatározásával írjuk le.

### Állapottér

Egy adat **típus-értékhalmaza** az adat lehetséges értékeiből áll. **Állapotnak** hívjuk azt az érték-együttest,
amikor egy feladat vagy egy program _minden_ adata felvesz a saját típus-értékhalmazából egy-egy értéket.

Formálisan:

Legyenek $A_1, ... , A_n (n\in\mathbb{N}^+)$ típusérték-halmazok, és a halmazokat
azonosító (egyedi, páronként különböző) $v_1, ... , v_n$ címkék (változók)

Minden cimke egy adatot (változó) jelöl. Egy állapot $\{v_1:a_1, ... , v_n:a_n\}$ (cimkézett értékek halmaza),
ahol minden változó felvesz egy értéket a hozzátartozó típus-értékhalmazból. ($a_i\in A_i$)

Az összes így képzett állapot halmazát **állapottérnek** nevezzük:

$$A := \{ \ \{v_1:a_1, ... ,v_n:a_n\} \ | \ a_i\in A_i \ (i=1,...,n) \ \}$$


### Feladat

A feladat egy kapcsolat (leképezés) a bemenet és az eredmény között: $F \subseteq A \times A$

Figyeljük meg, hogy az $F$ reláció csak része az $A\times A$ descartes-szorzatnak. Mivel azonban a kiinduló
állapotok csak az állapottér egy részhalmazát képzik, illetve az ezekhez rendelt állapotok ugyancsak az állapottérnek
egy részhalmazát képzik, így érthető, hogy a feladat nem feltétlenül érvényes a teljes állapottéren.

Példa:

Osztója reláció

Kérdés: $n$ osztója-e $d$-nek, melyet az $l$ logikai változó jelöl.

\begin{align*}
    A & = ( n:\mathbb{Z}, d:\mathbb{Z}, l:\mathbb{L} ) \\
    F & \subseteq A \times A \\
    & \text{ahol} \\
    D_f & = \{\{n,d,l\} \in A \ | \ d \neq 0 \} \\ 
    \forall a & \in D_F : F(a) = \{ \{n, d, l\} \in A \ | \ l = d|n \}
\end{align*}

Tehát láthatjuk, hogy az $F$ értelmezési tartományába csak azok az állapotok tartoznak bele, ahol az osztó nemnulla.
Az $l$ változó értéke $F(a)$-ban pedig aszerint alakul, hogy az $n$ osztja-e $d$-t.

#### Előfeltétel és  utófeltétel
Válasszunk egy $P$ paraméterhalmazt, mellyel az $F$ feladat felbontható két reláció kompozíciójára:
$$F = F_1 \circ F_2$$
ahol $F_1 \subseteq A \times P$ és $F_2 \subseteq P \times A$, úgy hogy: $\forall a \in D_F: F(a) = F_2(F_1(a))$

Ekkor definiálni tudjuk a feladat elő- és utófeltételét:

$\forall p \in P:$

* $Ef_P : A \rightarrow \mathbb{L}$    melyre   $[Ef_P] = F_1^{(-1)}(p)$
* $Uf_P : A \rightarrow \mathbb{L}$    melyre   $[Uf_P] = F_2(p)$

Itt a $Q : A \rightarrow \mathbb{L}$ egy állítás, aminek az igazsághalmaza: $[Q] := \{q \in Q \ | \ Q(a) \ igaz \}$. Tehát
$Ef$ olyan állítás, mely a feladat minden kezdőállapotára igazat ad, illetve az $Uf$ olyan állítás, mely az $F(a)$
állaptokra ad igaz értéket.

### Program

Egy programot sokféleképpen lehet megadni. (program-gráf, strukogram, automaták, utasítások, pszeudo- vagy programnyelv).

A program alaptermészete az, hogy különböző végrehajtásokat okoz. Tehát egy program a lehetséges
végrehajtásainak összessége. Egy ilyen végrehajtás sorozatos állapot-változásokat idéz elő, ennél fogva leírható egy
állapotsorozattal.

Példa:

$A = (n : [-5, ..., \infty ) )$

```Python
    while n != 10:
        n = n + sgn(n)
```
Ennek a lehetséges végrehajtásai a következők: 
```
     0: <0,0,0,0,0, ... >               nem terminál
     4: <4,5,6,7,8,9,10>                terminál
    10: <10>                            terminál
    13: <13,14,15,16, ... >             nem terminál
    -2: <-2,-3,-4,-5, fail >            abortál
```

A program lehet **nem-determinisztikus** (nem mindig ugyanazt az állaposorozatot adja a kezdőállapból indítva), lehetnek 
**segédváltozói**, lehet **véges** vagy **végtelen hosszú**, illetve leállhat **hibás** állapotban
vagy speciálisan **holtpontban**.

#### Alap-állapottér

A program alap-állapottere az **program interfésze**, mellyel a program a környezetével kommunikál (kezdőállapotát
a környezet adja, végállapotát a környezet kapja). Illetve ez írja le a program **alap-változóit**, melyek a program
működése során végig léteznek.

#### Fromális specifikáció

* Legyen $A$ az **alap-állapottér** ( $\text{fail} \notin A$ )
* Legyen $\overline{A}$ azon (véges komponensű) állapotterek úniója, melyeknek $A$ altere:

$$ \overline{A} := \bigcup_{A \leq B} B $$

* Jelöljük $H^{**}$-gal a $H$ elemeiből képzett összes sorozatot (lehet végtelen is).

Ezek alapján a $A$ feletti programnak hívjuk azt az
$$ S\subseteq A \times (\overline{A} \cup \text{fail} )^{**} $$ 

relációt, melyre fennállnak a következők:

1. $D_S = A$

    a program értelmezési tartománya az alap-állapottér.
2. $\forall a \in A : \forall \alpha \in S(a): \ |a| \geq 1 \land a_1 = a$

    az állapotsorozat legalább egy hosszú és a első állapota mindig az alap-állapottérből való.
3. $\forall \alpha \in R_S : \forall i \ (1 \leq i < |\alpha| ) : \alpha_i \neq \text{fail}$

    csak az utolsó elem lehet `fail` a végrehajtási állapotsorozatban
4. $\forall \alpha \in R_S : |\alpha| < \infty \longrightarrow \alpha_{|\alpha|} \in A \cup \{\text{fail} \}$

    a véges végrehajtások utolsó állapota vagy a `fail` vagy alap-állapottérbeli állapot.

### Megoldás

Egy program akkor old meg egy feladatot (a program helyes a feladat szempontjából),
ha végrehajtásai a feladat kezdőállapotaiból indulva a feladat megfelelő célállapotaiban állnak meg. Ekkor a feladat
állapottere és a program alap-állapottere azonos kell legyen.
Ilyenkor a program végrehajtásai között találjuk a feladat kezdőállapotából induló végrehajtásokat,
amelyekről azt kell eldönteni, hogy terminálnak-e (hibátlan véges hosszú) és végállapotuk a feladat által megkívánt
valamelyik célállapot lesz-e.

#### Megoldás minősített esetei

* **Parciális helyesség**: Ha a program a feladat kezdőállapotaiból indulva leáll, akkor ezt a feladatnak
    megfelelő célállapotban teszi. (A leállást nem követeljük meg.)
* **Leállás**: A feladat kezdőállapotából indulva leáll a program. (Hány vagy legfeljebb hány lépés múlva
    következik ez be? Kizárható-e a végtelen vagy a hibás működés, ez utóbbiba beleértve a holtpont helyzet
    kialakulását is.)
* **Teljes helyesség**:
    A program a feladat kezdőállapotaiból indulva a feladatnak megfelelő célállapotban (hibátlanul) áll le.
* **Gyengén teljes helyesség**: Ilyenkor a helyesség-vizsgálat során figyelmen kívül hagyjuk a holtpont kialakulását.

2.Elemi programok és program konstrukciók definíciói <a name="chapter02"></a>
---------------------------------------
//TODO

* elemi programok
    + üres
    + értékadás
* program konstrukciók
    + szekvencia
    + elágazás
    + ciklus
    + atomi utasítás
    + várakozó utasítás
    + párhuzamos blokk

3.Nem-determinisztikus strukturált programok formális verifikációja <a name="chapter03"></a>
---------------------------------------

//TODO: A helyesség-vizsgálati módszerek menete, a nevezetes programszerkezetek helyességének szabályai

4.Párhozamos programok formális verifikációja <a name="chapter04"></a>
---------------------------------------

//TODO: A helyesség-vizsgálati módszerek menete, a nevezetes programszerkezetek helyességének szabályai

5.Az interferencia-mentesség és a holtpont-mentesség vizsgálata <a name="chapter05"></a>
---------------------------------------

(Owicki-Gries) 

6.A kölcsönös kizárás és megvalósítása <a name="chapter06"></a>
---------------------------------------
7.További források <a name="references"></a>
---------------------------------------
* Előadás diasor