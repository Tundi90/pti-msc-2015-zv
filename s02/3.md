S2-03 A szerződésalapú programtervezés
=======================================
Tartalom
---------------------------------------

1. [A szerződésalapú programtervezés és -megvalósítás módszere, célja, szerepe](#chapter01)
2. [Szerződések leírását támogató nyelvi eszközök az Eiffel nyelvben](#chapter02)
3. [A szerződések formális jelentése Hoare-hármasokkal](#chapter03)
4. [A szerződések és a típusrendszer viszonya](#chapter04)
5. [Szerződések és objektum-orientáltság: öröklődés és felüldefiniálás](#chapter05)
6. [Üres referenciák](#chapter06)
7. [Kivételek](#chapter07)
8. [További források](#references)

1.A szerződésalapú programtervezés és -megvalósítás módszere, célja, szerepe <a name="#chapter01"></a>
---------------------------------------

### A szerződésalapú programtervezés módszere
A szerződésalapú programtervezés (Design by Contract, DbC) Bertrand Meyer nevéhez fűződik és a 80-as évek közepén
 alakult ki. A módszer három megközelítésen alapszik: a formális verifikáció, formális specifikáció, és a Hoare-hármasok.

Az elképzelés lényege, hogy a rendszer komponensei együttműködésének elősegítéséhez a résztvevők kölcsönösen
kötelezettségeket vállalnak, melyek segítségével biztosítva lesznek a haszonról. Ez a megközelítés nem meglepő módon az
üzleti élettel hozható párhuzamba, ahol a felek az előbb említetteknek megfelelően szerződéseket kötnek.

Példa:

* A _kereskedő_ terméket ad (kötelezettség), és  feltételezi, hogy a _vásárló_ fizetett érte (haszon)
* A _vásárló_ fizet a termékért (kötelezettség), és feltételezi, hogy a _kereskedő_ terméket biztosít (haszon)
* Mindkét résztvevő eleget tesz olyan egyéb megkötéseknek, mint például a jogi szabályok betartása

A fenti példának megfelelően egy Objektum-orientált programban egy osztály egy szolgáltatásának három kérdésre kell
választ adnia:

* Mik az eljárás megfelelő működéséhez szükséges megkötések - **előfeltétel**
* Milyen eredményt garantál az eljárás (az előfeltételben megszabottak alapján) - **utófeltétel**
* Milyen állapotot tart meg az eljárás (amit feltételezünk az eljárás előtt és garantálunk az után) - **invariáns**

### A szerződésalapú megvalósítás módszere
Sok programozási nyelv ad támogatást a DbC-hez hasonló technikához az `assert`-ek segítségével. A szerződésalapú
programtervezés szerint azonban a szoftver megfelelőségéhez alapvető, hogy ezek a szerződések a tervezés szerves részét
képezzék. (A gyakorlatban ez azt jelenti, hogy az `assert`-ek kerülnek először megírásra.) A szerződéseket egyébként
meg lehet fogalmazni comment segítségével, alá lehet támasztani tesztekkel (vagy mindkettő), ha a programnyelv nem ad
más támogatást.

Nyelvek melyek natívan támogatják a szerződésalapú programtervezést: _Eiffel_, _Ada 2012_, _Clojure_, stb.

Nyelvek melyekhez létezik third-party könyvtár: _Java_, _C#_, _C_, _C++_, _Ada_, _JavaScript_, _PHP_, _Python_, _Ruby_,
_Groovy_, stb.

Ahogy az előbb már láthattuk a szerződések a legtöbb programozási nyelvben `assert`-ek segítségével fogalmazható meg.
Azonban ha a program komponensei nem sértik meg a szerződéseket (bug-mentesek), ezek az `assert`-ek nem fognak hibát
jelezni. Mivel ezek az ellenőrzések nagy hatással lehetnek a teljesítményre, így csak _debug_ módban szokták őket
bekapcsolni, _release_ módban ezek a fordítás során törlésre kerülnek.

A szerződésalapú programtervezés szerint a szerződések megszegése kritikus hiba kell legyen. Ez annyit tesz, hogy a
programnak hibát kell jeleznie, ha olyan dolgok történik, ami a szerződések szerint nem megengedett. Így tehát a hívó
fél felelőssége lesz, hogy megfelelően működjön a program. Ezzel a szemlélettel tehát az `assert`-ek használata egy
megfelelő megoldás lehet. Némileg ellentétes felfogás a defenzív programozás, ahol a szolgáltatónak kell
felkészülnie a különböző nem megengedett esetekre és aszerint eldönteni, hogy mi történjen.

### A szerződésalapú program célja, szerepe
A szerződésalapú programtervezés elsődleges célja, hogy bug-mentes OO programokat tudjunk készíteni, de több előnnyel
is jár a használata:

* Az objektum-orientált megközelítés (vagy általánosabban a szoftverfejlesztés) megértését segíti elő
* Szisztematikus megközelítést ad bug-mentes Objektum-orientált rendszerek építéséhez
* A debuggoláshoz, tesztéshez (vagy általánosabban a quality assurance-hez) nyújt hatékony keretrendszert
* Szoftverkomponensek dokumentálására ad módszert.
* Az öröklődési mechanizmus megértését és kezelését segíti elő
* A abnormális esetek kezelésére ad technikát, ami biztonságos és hatékony nyelvi konstrukció a kivételkezelésre.

2.Szerződések leírását támogató nyelvi eszközök az Eiffel nyelvben <a name="#chapter02"></a>
---------------------------------------
#### Előfeltétel, utófeltétel
A szerződésalapú programtervezésben talán a legfontosabb szerepet a metódusok elő- és utófeltételei kapják. Az Eiffel nyelvben ezeket külön szintaktikus
elemekkel (blokkokkal) lehet kifejezni. (Eiffelben mind az attribútumokat, mind a metódusokat _feature_-öknek nevezzük)
Egy feature (metódus) a követekzőképp néz ki:
```Eiffel
feature_name(...): C is -- zárójelben a paraméterek,
                        -- majd a visszatérési érték típusa
    require
        -- előfeltétel
    local
        -- lokális változók
    do
        -- implementáció
    ensure
        -- utófeltétel
    end
```

Az elő- és utófeltételek minden sorában egy logikai kifejezést kell írni, melyeket akár fel is cimkézhetünk:
```Eiffel
     put (x: ELEMENT; key: STRING) is
                     -- Insert x so that it will be retrievable through key.
             require
                     container_is_not_full: count <= capacity
                     key_is_not_empty: not key.empty
             ...
```
A fenti példában láthatjuk, hogy egy gyűjtemény `put` feature-éhez megfogalmaztunk egy `container_is_not_full`
előfeltételt, mely azt mondja ki, hogy a gyűjtemény nem lehet tele a berakás esetén, illetve egy `key_is_not_empty`
előfeltételt, miszerint a kulcs nem lehet az üres sztring.

Az utófeltétel vizsgálata esetén már olya vizsgálatokat is végezhetünk, melyekben a múltbéli állapotra hivatkozunk. Erre
az `old` kulcscszót használjuk:

```Eiffel
     put (x: ELEMENT; key: STRING) is
                     -- Insert x so that it will be retrievable through key.
             require
                -- precondition
             do
                -- implementation
             ensure
                has (x)
                item (key) = x
                count = old count + 1
```
Láthatjuk, hogy az utófeltételben megfogalmaztuk, hogy a feature meghívása után az elemnek a gyűjteményben kell lennie,
méghozzá a kulccsal elérhetőnek kell lennie. Ezen felül az `old` kulcsszó segítségével ki tudtuk fejezni, hogy az új
elemszám a régi elemszámhoz képest eggyel nagyobbnek kell lennie.

_Megjegyzés: Létezik egy **strip** kulcscszó is, mellyel bonyolultabb utófeltételek esetén azt tudjuk meghatározni, hogy
a kizárólag a felsorolt attribútumok változhatnak meg._

#### Osztályinvariáns
Ahogy a bevezetőben is olvashattuk az elő- és utófeltételek mellett az osztályinverians is fontos szerepet kap a
szerződések szempontjából. Ezzel határozzuk meg egy osztály helyes állatpotainak halmazát, melyet ugyanúgy logikai
állításokkal tudunk leírni. Az osztály szintaxisa Eiffelben a követekző:
```Eiffel
class MYCLASS
create
    make -- Konstruktor feature-ök
feature {A}
    -- A osztály számára látható feature-ök
feature {B}
    -- B osztály számára látható feature-ök
invariant
    -- osztályinvariánsok
end
```

Az osztályinvariánst pedig egy Stack esetén például a következőképp tudjuk leírni:

```Eiffel
class STACK[T]
creation
    make
feature
    size: INTEGER

    capacity: INTEGER
    do
        Result := data.count
    ensure
        Result > 0
    end -- capacity

feature {}

    data: ARRAY[T]

invariant
    data.lower = 1
    data.upper = capacity
    0 <= size
    size <= capacity
end -- class STACK
```

#### Ciklusok

Eiffelben a ciklusok is kiemelt figyelmet kapnak, mivel ezeknek is lehet megkötéseket, kiegészítő információkat
adni. A nyelv Programozáselméletből ismert _ciklus invariáns_ és _variáns függvény_ kifejezésére ad lehetőséget.
Egy ciklus szintaxisa a következő:

```Eiffel
from
    -- incializációs blokkok
invariant
    -- ciklus invariáns
until
    -- terimánálási feltételezi
loop
    -- ciklusmag
variant
    -- cilus variáns
end
```

A _ciklus invariáns_ egy olyan állítás, melynek a ciklus előtt, majd minden iteráció után igaznak kell lennie.
A _ciklus variáns_ vagy _variáns függvény_ pedig olyan nem-negatív egész szám, melynek értéke minden iteráció után
legalább eggyel csökken. Mivel egy nem-negatív egész szám nem csökkenthető a végtelenségig, illetve mivel kötelező a
csökkenés így biztosítva van a terminálás. (Másként: A variáns függvény szigorúan monoton csökkenő, így el fogja érni a
nullát.)


//TODO:
* Csak egyszerűbb állítások. (Forall nem működik)
* check

3.A szerződések formális jelentése Hoare-hármasokkal <a name="#chapter03"></a>
---------------------------------------
4.A szerződések és a típusrendszer viszonya <a name="#chapter04"></a>
---------------------------------------
//TODO
* Current
* Anchored type 
    + polymorphyc CAT call
* expandált és referncia típusok, Void(attached, detachable)
* deferred (feature, class vagy csak implementáció)

5.Szerződések és objektum-orientáltság: öröklődés és felüldefiniálás <a name="#chapter05"></a>
---------------------------------------
//TODO:
* öröklődési fa
* Covariancia, contravariancia, require else, ensure then
    + (osztályinverians és-elődik)
* Könyvtárból öröklődés
* Többszörös öröklődés, átnevezés
* láthatóságok

6.Üres referenciák <a name="#chapter06"></a>
---------------------------------------
7.Kivételek <a name="#chapter07"></a>
---------------------------------------
8.További források <a name="#references"></a>
---------------------------------------
* http://kto.web.elte.hu/hu/oktatas/eiffel/anyagok/eloadasok/
* https://en.wikipedia.org/wiki/Design_by_contract
* https://www.eiffel.com/values/design-by-contract/introduction/
* http://se.ethz.ch/~meyer/publications/computer/contract.pdf
* http://www.cse.yorku.ca/~eiffel/ISE/doc/html/manuals/language/intro/deferred.maker.html
* https://archive.eiffel.com/doc/online/eiffel50/intro/language/invitation-06.html
* https://www.eiffel.org/doc/eiffel/An%20Eiffel%20Tutorial%20%28ET%29
